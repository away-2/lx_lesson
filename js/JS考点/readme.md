# 1. 数据类型
- 原始类型：String, Number, Boolean, undefined, null, bigInt, Symbol

  123.toString()  // '123'
  undefined.toString()  'error'
  null.toString() 'error'

- 引用类型：
  1. 原始类型存在栈中，引用类型存在堆中


# 2. typeof VS instanceof
1. typeof 能准确的判断除 null 之外的所有原始类型, 因为是通过接收到的值的二进制来区别对象的，二进制前三位为 0 的就是对象，而null的二进制全部是 0
2. instanceof 通过判断对象的原型是否等于构造函数的原型来判断类型
3. Object.prototype.toString.call(xxx).slice(8, -1)


# 3. 类型转换
  - 转布尔值 
  - 转数字
  - 转字符串

  - 对象转原始类型: 会调用对象内置的 [[ToPrimitive]] 函数
    1. 判断接受的值是原始类型，就返回
    2. 调用valueOf(), 如果能转成原始类型，就返回原始类型的值
    3. 调用toString(), 如果能转成原始类型，就返回原始类型的值
    4. 否则，就报错

  - 对象转布尔值时，一律是true

  - 四则运算
    + 为数字和字符串准备的
    

# 4. this
  1. 默认绑定: 函数在哪个词法环境下生效，函数的this就指向哪里
  2. 隐式绑定: 当函数被上下文对象调用时
  3. 隐式丢失: 当函数被多个对象所拥有且调用时
  4. 显示绑定: call, apply, bind

  - 箭头函数: 没有this这个概念，写在箭头函数内的this也是它外层非箭头函数的, 箭头函数不能作为构造函数


# 5. == VS ===
  - == 判断过程：
    1. 先判断两者类型是否相同，相同就比较值
    2. 类型不相同，就需要进行隐式类型转换
    3. 在转换前先判断，是否为undefined 和 null，是的话就返回true
    4. 原始类型往number上转
    5. 如果有一方是对象，那么先将对象转换为原始值，再判断

  - === 直接判断类型和值是否都相等


# 6. 闭包
 - 什么是闭包：
  当函数A内部定义的函数B在A外面被调用，A的执行上下文被销毁时会保留下B所引用到的变量集合，这个集合，我们称之为闭包


# 7. 深浅拷贝
 - 浅拷贝：拷贝引用地址，受原对象的影响
  1. Object.assign
  2. {...obj}

- 深拷贝：对原对象进行层层拷贝
  1. JSON.parse(JSON.stringify(obj)) 但是：无法处理循环引用，无法拷贝Symbol和undefined和function


# 8. 原型、原型链
  - 对象原型（隐式原型）__proto__
  - 原型（显示原型）prototype

  1. Object 是所有对象的祖先，所有对象都可以通过__proto__找到它
  2. Function 是所有函数的祖先，所有的函数都可以通过__proto__找到它
  3. 函数的 prototype 也是一个对象，它是由 Object 创建的
  4. __proto__指向原型，它将对象和原型连接起来组成了原型链


# 9. var、let、const
  - 什么是提升？
    1. 用var声明的变量会存在声明提升，提升到当前作用域的顶部
    2. 函数声明会成体提升，提升到当前作用域的顶部

  - 什么是暂时性死区？
    1. 用let、const声明的变量在编译的时候会被限制适用范围

  - var、let、const 的区别？
    1. let、const 声明的变量不会被挂载到window上
    2. let、const 不能重复声明变量
    3. const 声明的变量不允许重新赋值


# 10. 继承
  1. 原型链继承
  2. 经典继承
  3. 组合继承
  4. 寄生组合继承
  5. class

# 11. proxy
  代理对象上的各种方法，可以实现数据响应式

# 12. map, filter, reduce

# 13. 异步
 - 并发：在一段时间之内，通过任务切换来完成所有的任务
 - 并行：同时完成多个任务

 - 回调：回调地狱
  1. 函数嵌套过深，牵一发而动全身
  2. 嵌套过多，很难处理错误

 - Generator：可以通过yield暂停代码的执行，在任务的通过next控制代码执行的步骤

 - Promise

 - async/await
  不需要.then调用链，代码结构清晰，并且也能优雅的解决回调地狱问题
  

# 14. Event Loop
  - JS 单线程的好处？
    1. 不会造成内存冲突
    2. 节约内存
    3. 没有锁的问题

  - 什么是执行栈？
    js引擎在执行js代码时维护的一个栈结构空间。用于存储函数的调用（执行上下文）

  - 浏览器中的事件循环机制？
    1. 执行同步代码（宏任务）
    2. 当执行栈为空后，查询是否有异步代码要执行
    3. 执行所有的微任务
    4. 需要的话，会渲染页面
    5. 执行宏任务，也是下一次的事件循环的开始
  
  - 微任务：Promise.then(),process.nextTick(),MutationObserver
  - 宏任务：script(同步代码),setTimeout(),setImmediate(),setInterval(),I/O,UI-rendering(页面渲染) 

# 15. 浏览器中的考点
 # 1. js事件机制
 - 事件的触发过程
  1. 从window上往事件触发处传播，此过程称之为捕获，遇到的捕获事件会触发
  2. 达到事件触发处，触发注册的事件
  3. 从事件触发处往window上传播，此过程称之为冒泡，遇到的冒泡事件会触发

 - 事件代理
  1. 节约内存
  2. 提升性能（不需要给子节点注销事件）


# 2. 跨域
  - 什么是跨域？
     协议 - 域名 - 端口号  有一个不同都算跨域

  - 浏览器为什么要有同源策略？
     禁止第三方站点朝A网站 请求数据，降低CSRF攻击的可能

  - 解决跨域的方法
    1. jsonp (需要后端配合，只能get请求)
    2. cors (纯后端实现，通过响应头告诉浏览器哪些 源 不需要走同源策略)
    3. node 代理 (同源策略不发生在服务端，通过一段可以跨域的node代码 帮前端请求其他后端的数据)
    4. nginx
    5. postMessage (当页面中使用了iframe嵌套了子页面，父子页面不同源时，postMessage可以实现通信)
    6. domain (通过声明父子页面的 document.domain = 'xxx', 来告诉浏览器无需跨域)
    7. WebSocket (socket协议不受同源策略限制)
    
    

  - 请求预检

  1. CSRF攻击（Cross-site request forgery）
    黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发情跨站请求
  






