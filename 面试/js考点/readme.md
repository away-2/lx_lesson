# 4. == VS === ?
    == 只判断值是否相等，会发生隐式类型转换
    === 不发生隐式类型转换，判断值相等

# 5. 说说深拷贝和浅拷贝，如何实现一个深拷贝？
    - 是什么
        因为在js中，基本数据类型是保存在栈当中，而引用类型是保存在堆当中
        （指针在栈中），所以深拷贝和浅拷贝通常只针对引用类型来讨论

        深拷贝：拷贝原对象，新的对象会受原对象修改的影响
        浅拷贝：拷贝原对象，新的对象不会受原对象修改的影响
    
    - 常见的深浅拷贝方法：
        浅拷贝：Object.assign, {...obj}, slice(0), concat(arr), [...arr]
        深拷贝：JSON.parse(JSON.stringify(obj)) 但是无法处理循环引用，无法拷贝 Symbol 和 undefined 和 function，
        正则，NaN，Infinity，Date
    
# 6.说说你对闭包的理解
    -是什么
        当调用一个外部函数返回的一个内部函数时，即使外部函数执行完毕后，但内部函数
        引用了外部函数的变量，那么这些变量依然被会保存在内存中，我们把这个变量的集合称之为闭包。

    - 使用场景
        1. 创建私有变量
        2. 延长变量的生命周期
    
    - 缺点
        内存泄漏
        解决上述内存泄漏，其实只需要将fn=null ，就是fn 不指向了，那么这个AO的内存就会被释放，它和bar函数是互相指向的，但是按照GC最新的规则是会被回收的，它们就被销毁了。

# 7. 说说你对作用域的理解
    - 是什么
        变量（上下文）和函数生效的区域，作用域决定了该区域中的变量和资源的可见性

    - 种类
        1. 全局作用域
        2. 函数作用域
        3. 块级作用域 let, const
    
    - 作用域链
        在js中，当需要查找一个变量时，js引擎会在当前作用域中查找该变量，如果找不到，就会去
        上层作用域中查找，直到找到变量或者来到全局作用域下，这种查找关系就称之为作用域链

# 8. 说说你对原型的理解
    - 是什么
        在js中，对象具有__proto属性，称之为对象原型（隐式原型），
        它等于创建该对象的构造函数的显示原型

        函数具有prototype属性，我们称之为显示原型（原型），它是一个对象，
        在它内部添加的属性会被函数的实例对象所继承

        对象在查找属性时，会先在自己显示属性上查找，找不到才会去对象原型上查找，
        层层往上，直到找到该属性或者达到原型链的末端（null）

    - 原型链：
        对象的原型也是对象，还有原型，对象在原型上层层查找属性的这种链状关系，
        就称之为原型链，原型链末端是 Obeject.prototype

# 9. 说说js中的继承
    - 是什么
        是一种可以让 类A 访问到 类B 中的所有的属性方法的手段

    - 实现方式
        1. class extends
        2. 原型链继承
        3. 构造函数继承
        4. 组合继承
        5. 寄生组合继承

# 10. 说说你对this的理解
    - 是什么
        js中提供的一个函数运行时的关键字，用来代指某个区域的作用域，总能指向调用它的对象

    - 绑定规则
        1. 默认绑定
        2. 隐式绑定
        3. 隐式丢失
        4. 显示绑定：call，apply，bind
        5. new绑定：this指向实例对象

    - 箭头函数
        箭头函数没有this这个概念，即使在箭头函数中写了this，那也代表的是箭头函数外层
        的非箭头函数的this

# 11. 说说你对js中执行上下文和执行栈的理解
    - 是什么
        执行栈：是js引擎在编译js代码环节维护的一个栈结构，用来存放各个执行上下文对象

        执行上下文：全局执行上下文，函数体执行上下文，是js引擎梳理当前环境下的资源访问
        关系的一个对象
    
    - 生命周期
        函数编译（创建） --> 函数执行（执行） --> 回收

        1. 创建：确定this的值，创建词法环境，创建变量环境
        2. 执行：变量赋值，代码执行
        3. 回收：执行上下文出栈的过程 （垃圾回收机制）

# 12. 谈谈js中的事件模型
    - 事件流
        js中的各种事件执行都存在一个传播的过程，这个过程会经历三个阶段，事件的
        捕获阶段，处于目标阶段，事件的冒泡阶段
        stopPropagation()  // 阻止事件流的传播
        stopImmediatePropagation() // 阻止自身的其他事件触发

    - 事件模型
        1. 原始事件模型 （DOM0）兼容性最好，只能同时绑定一个事件，没有捕获阶段，没有处于目标阶段，只有冒泡阶段
        2. 标准事件模型 （DOM1）兼容性良好，能同时绑定多个事件，有捕获阶段，处于目标阶段和冒泡阶段
        3. IE事件模型  （基本不使用）只有处于目标阶段和冒泡阶段
        
# 13. typeof VS instanceof
    - typeof 可以判断除 null 之外的所有原始类型（因为是通过接收到的值的二进制来区别对象的，
      二进制前三位为 0 的就是对象，而null的二进制全部是 0），得到一个字符串

    - instanceof 用来判断引用类型，根据对象的隐式原型是否等于构造函数的
      显示原型来判断的，得到一个布尔值

# 14. 说说什么是事件代理，应用场景？
    - 是什么
        借助冒泡机制，将原本应该绑定在目标容器上的事件，绑定到它外层容器上

    - 应用场景
        1. 减少整体页面需要注册的函数的数量，提升性能，主要用在当子容器是循环生成
           的时候需要注册事件时

# 15. 说说 new 操作符都干了些什么？
    1. 创建一个新对象
    2. 将对象的原型赋值为函数的原型
    3. 将函数的this指向该对象
    4. 执行该函数
    5. 返回创建的对象

# 16. Ajax
    - (Async JavaScript and XML)
    1. 借助 XMLHttpRequest 创建请求对象
    2. 封装 get，post...等请求方式
    3. 处理参数的传递
    4. 监听请求对象的状态变化

    


